
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Sweet Match ‚Äî Responsive</title>
<style>
  :root{
    --cell: 68px;           /* dynamically recalculated by JS */
    --gap: 8px;
    --bg: #0b0f18;
    --panel: #101727;
    --text: #eaf0ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; overscroll-behavior:none; -webkit-tap-highlight-color: transparent;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", Arial;
    background: radial-gradient(1200px 800px at 80% -10%, #1c2657 0, var(--bg) 55%);
    color: var(--text);
    display:flex; flex-direction:column; min-height:100svh;
  }
  header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; }
  header h1{ margin:0; font-size:20px; letter-spacing:.2px }
  .toggle{ display:none; background:#162247; border:1px solid rgba(255,255,255,.15); color:var(--text); border-radius:10px; padding:8px 10px; font-weight:700 }

  .wrap{ flex:1; display:grid; grid-template-columns: 1fr 360px; gap:18px; align-items:start; width:min(1200px, 96vw); margin:0 auto 16px; }
  .board-wrap{ position:relative; padding:16px; background: color-mix(in srgb, #000 18%, var(--panel)); border-radius:18px; box-shadow:0 10px 28px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.06); }
  .board{ width:100%; display:grid; grid-template-columns: repeat(8, var(--cell)); grid-template-rows: repeat(8, var(--cell)); gap: var(--gap); touch-action: none; }
  .fx{ position:absolute; inset:16px; pointer-events:none; }

  /* glossy ball base */
  .cell{ width:var(--cell); height:var(--cell); border-radius:50%; cursor:pointer; position:relative; transition:transform .08s ease, filter .15s ease;
    box-shadow: inset 0 -10px 16px rgba(0,0,0,.35), inset 0 10px 14px rgba(255,255,255,.18), 0 8px 12px rgba(0,0,0,.35);
    display:block; border:none; padding:0; background:transparent; touch-action:none; }
  .cell:active{ transform:scale(.94) }
  .selected{ outline:3px solid rgba(255,255,255,.85); outline-offset:3px; filter:saturate(1.2) brightness(1.05) }
  .clearing{ animation:pop .35s ease-in forwards }
  @keyframes pop{ to{ transform:scale(0); opacity:0 } }
  .cell::before, .cell::after{ content:""; position:absolute; inset:0; border-radius:50%; pointer-events:none; }
  .cell::before{ background: linear-gradient(160deg, rgba(255,255,255,.25) 0%, rgba(255,255,255,.08) 35%, rgba(0,0,0,.0) 40%, rgba(0,0,0,.25) 100%);
    mix-blend-mode: screen; opacity:.9; clip-path: ellipse(85% 55% at 30% 20%); transform: translate(-6%, -6%) rotate(-8deg); }
  .cell::after{ background: radial-gradient(60% 60% at 28% 22%, rgba(255,255,255,.85) 0 22%, rgba(255,255,255,.0) 40%), radial-gradient(40% 40% at 70% 70%, rgba(0,0,0,.3) 0 60%, rgba(0,0,0,0) 70%);} 

  /* bright bases */
  .t0{ background:linear-gradient(#ff4d4d,#ff4d4d)}
  .t1{ background:linear-gradient(#ffcc00,#ffcc00)}
  .t2{ background:linear-gradient(#33ccff,#33ccff)}
  .t3{ background:linear-gradient(#66ff66,#66ff66)}
  .t4{ background:linear-gradient(#cc66ff,#cc66ff)}
  .t5{ background:linear-gradient(#ff66cc,#ff66cc)}

  .sidebar{ background: color-mix(in srgb, #000 14%, var(--panel)); padding:16px; border-radius:18px; box-shadow:0 10px 28px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.05); }
  .row2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  .card{ background:#0d1328; border:1px solid rgba(255,255,255,.09); border-radius:12px; padding:12px; text-align:center }
  .label{ font-size:12px; opacity:.8 }
  .value{ font-size:26px; font-weight:800; margin-top:2px }
  .btns{ display:flex; gap:8px; flex-wrap:wrap; margin:12px 0 }
  button{ background: linear-gradient(180deg,#5f85ff,#3c5df7); color:white; border:none; padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:700; box-shadow: 0 8px 18px rgba(60,93,247,.35); }
  button.secondary{ background:none; border:1px solid rgba(255,255,255,.18); color:var(--text); box-shadow:none }
  .help{ font-size:13px; opacity:.92; line-height:1.6; margin-top:8px }
  .goals{ margin-top:8px; display:grid; gap:10px }
  .goal{ background:#0d1328; border:1px solid rgba(255,255,255,.09); padding:10px; border-radius:10px }
  .progress{ height:8px; background:#0b0f1a; border-radius:99px; overflow:hidden; border:1px solid rgba(255,255,255,.08) }
  .bar{ height:100%; background:linear-gradient(90deg,#35d07f,#8af0b6); width:0% }
  .goal-list{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px }
  .chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 8px; border-radius:999px; background:#0b0f1a; border:1px solid rgba(255,255,255,.08); font-size:12px }
  .dot{ width:14px; height:14px; border-radius:50% }
  .leader{ margin-top:12px; background:#0d1328; border:1px solid rgba(255,255,255,.09); border-radius:12px; padding:12px }
  .leader h3{ margin:0 0 8px; font-size:14px; letter-spacing:.2px }
  .leader .row{ display:flex; justify-content:space-between; gap:8px; padding:6px 8px; border-radius:8px }
  .leader .row:nth-child(odd){ background:#0b0f1a }
  .leader .row .name{ font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width: 160px }
  .leader .row .pts{ opacity:.9 }
  .leader .empty{ opacity:.7; font-size:12px }
  .donate{ margin-top:12px }
  .paybtn{ display:inline-flex; align-items:center; gap:10px; background: linear-gradient(180deg,#15a2ff,#0a7bd6); padding:10px 14px; border-radius: 12px; color:white; font-weight:700; text-decoration:none; box-shadow: 0 8px 18px rgba(21,162,255,.35) }

  /* Mobile layout: panel collapses below with toggle button */
  @media (max-width: 900px){
    .wrap{ grid-template-columns: 1fr; gap:12px; width:100%; padding:0 0 12px; }
    .board-wrap{ border-radius:0; padding:10px 8px 12px; box-shadow:none; }
    .sidebar{ border-radius:12px; margin:0 12px; }
    .toggle{ display:inline-block }
  }
</style>
</head>
<body>
  <header>
    <h1>Sweet Match üç¨</h1>
    <button id="toggle" class="toggle" aria-controls="side">Menu</button>
  </header>

  <div class="wrap">
    <div class="board-wrap">
      <div id="board" class="board" aria-label="Game board 8x8"></div>
      <div id="fx" class="fx"></div>
    </div>

    <aside id="side" class="sidebar" aria-label="Game panel">
      <div class="row2">
        <div class="card"><div class="label">Score</div><div id="score" class="value">0</div></div>
        <div class="card"><div class="label">Moves</div><div id="moves" class="value">30</div></div>
      </div>
      <div class="btns">
        <button id="newGame">New game</button>
        <button id="toggleMode" class="secondary">Mode: Moves</button>
        <button id="nextLevel" class="secondary">Next level</button>
      </div>
      <div class="goals">
        <div class="goal">
          <h3>Level goals</h3>
          <div class="progress"><div id="goalBar" class="bar"></div></div>
          <div id="goalList" class="goal-list"></div>
        </div>
      </div>
      <div class="help">
        <strong>How to play:</strong> click a ball, then click a neighboring cell (up/down/left/right) to swap and make matches of 3+. A line of 4 creates a <em>row/column blaster</em>, and 5 creates a <em>color bomb</em>.
      </div>
      <div class="leader" id="leader">
        <h3>Leaderboard (Top 10)</h3>
        <div id="lbList" style="margin-top:10px"></div>
      </div>
      <div class="donate">
        <a class="paybtn" href="https://paypal.me/AR110688" target="_blank" rel="noopener">Donate via PayPal</a>
      </div>
    </aside>
  </div>

<script>
  // ===== Fit board both for desktop and mobile =====
  function fitBoard(){
    try{
      const board = document.getElementById('board');
      if(!board) return;
      const wrap = board.parentElement; // .board-wrap
      const styles = getComputedStyle(board);
      const gap = parseFloat(styles.gap) || 6;

      // Width-constrained cell size
      const availW = wrap.clientWidth - gap * (COLS - 1);
      let cellW = Math.floor(availW / COLS);

      // Height-constrained cell size (desktop): try not to exceed viewport height minus header/paddings
      const header = document.querySelector('header');
      const headerH = header ? header.getBoundingClientRect().height : 0;
      const viewportH = (window.visualViewport ? visualViewport.height : window.innerHeight) || window.innerHeight;
      // Some margin for panel/paddings when two-column layout
      const verticalMargin = window.matchMedia('(min-width: 900px)').matches ? 60 : 140;
      const availH = viewportH - headerH - verticalMargin; // rough safe area
      let cellH = Math.floor(availH / ROWS);

      const cell = Math.max(34, Math.min(cellW, cellH));
      document.documentElement.style.setProperty('--cell', cell + 'px');
    }catch(e){}
  }

  // ===== Game engine (same as before) =====
  const ROWS = 8, COLS = 8, TYPES = 6;
  const MOVE_LIMIT = 30; const SCORE_PER_TILE = 10;
  let board = []; let elBoard, elFX; let selected=null; let busy=false; let score=0; let movesLeft=MOVE_LIMIT; let mode='moves'; let lastSwap=null;
  let levelIndex=0; let level=null; let collected={};
  const $ = s => document.querySelector(s);

  const Audio = { ctx:null, ensure(){ if(!this.ctx){ try{ this.ctx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } },
    beep(f=440,d=0.07,t='sine',g=0.05){ this.ensure(); if(!this.ctx) return; const T=this.ctx.currentTime; const o=this.ctx.createOscillator(); const G=this.ctx.createGain(); o.type=t; o.frequency.setValueAtTime(f,T); G.gain.setValueAtTime(g,T); G.gain.exponentialRampToValueAtTime(0.0001,T+d); o.connect(G).connect(this.ctx.destination); o.start(T); o.stop(T+d); },
    chord(freqs=[440,660],d=0.12,t='sine',g=0.04){ this.ensure(); if(!this.ctx) return; const T=this.ctx.currentTime; const G=this.ctx.createGain(); G.gain.setValueAtTime(g,T); G.connect(this.ctx.destination); freqs.forEach(f=>{ const o=this.ctx.createOscillator(); o.type=t; o.frequency.setValueAtTime(f,T); o.connect(G); o.start(T); o.stop(T+d); }); G.gain.exponentialRampToValueAtTime(0.0001,T+d); }
  };
  function sfxSwap(){ Audio.beep(420,0.06,'triangle',0.04); }
  function sfxInvalid(){ Audio.beep(180,0.10,'sawtooth',0.03); }
  function sfxClear(n=3){ Audio.chord([520,660,820].slice(0,Math.min(3,Math.max(1,n/3|0))),0.12,'sine',0.04); }
  function sfxSpecial(){ Audio.chord([320,480,640],0.16,'square',0.035); }
  function sfxWin(){ Audio.chord([660,880,990],0.3,'sine',0.05); }

  // ===== Public Leaderboard (SAFE) =====
  const API_URL = 'PASTE_YOUR_APPS_SCRIPT_WEB_APP_URL_HERE';
  const NICK_KEY = 'sm_nick_v1';
  function validApi(){ return /^https?:\/\//.test(API_URL); }
  async function fetchLB(limit=10){ if(!validApi()||typeof fetch!=='function') return []; try{ const res=await fetch(`${API_URL}?action=list&limit=${limit}`); const data=await res.json(); return (data&&data.ok&&Array.isArray(data.list))?data.list:[]; }catch(e){ console.warn('fetchLB failed',e); return []; } }
  async function postScore(name,pts){ if(!validApi()||typeof fetch!=='function') return {ok:false,offline:true}; try{ const body=new URLSearchParams({action:'add',name,score:String(pts)}); const res=await fetch(API_URL,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body}); return await res.json(); }catch(e){ console.warn('postScore failed',e); return {ok:false}; } }
  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m])); }
  async function renderLB(){ const listEl=$('#lbList'); if(!listEl) return; const list=await fetchLB(10); if(!list||list.length===0){ listEl.innerHTML='<div class="empty">No scores yet or leaderboard offline.</div>'; return;} listEl.innerHTML=list.map((r,i)=>`<div class="row"><span class="name">${i+1}. ${escapeHtml(r.name)}</span><span class="pts">${r.score}</span></div>`).join(''); }

  const inBounds=(r,c)=>r>=0&&r<ROWS&&c>=0&&c<COLS; const key=(r,c)=>r+","+c; const getType=cell=>cell?.t;

  function init(){
    elBoard=$('#board'); elFX=$('#fx');
    $('#newGame').addEventListener('click', newGame);
    $('#toggleMode').addEventListener('click', toggleMode);
    $('#nextLevel').addEventListener('click', ()=>{ levelIndex++; newGame(true); });

    // Mobile panel toggle
    const tgl=$('#toggle'); const side=$('#side');
    if(tgl){ tgl.addEventListener('click', ()=>{ side.classList.toggle('open'); }); }

    newGame(); renderLB(); fitBoard();
    window.addEventListener('resize', fitBoard);
    if(window.visualViewport){ visualViewport.addEventListener('resize', fitBoard); }
  }

  function toggleMode(){ mode=(mode==='moves')?'endless':'moves'; $('#toggleMode').textContent = `Mode: ${mode==='moves'?'Moves':'Endless'}`; newGame(); renderLB(); }

  function newGame(keepMode=false){ score=0; movesLeft=MOVE_LIMIT; updateHUD(); setupLevel(); updateGoalsUI(); generateBoard(); renderBoard(); if(!keepMode) selected=null; }

  function setupLevel(){ const baseMoves=MOVE_LIMIT; const scoreTarget=300+levelIndex*150; const colorsToCollect=2+(levelIndex%3); const counts=8+Math.min(20,levelIndex*3); const picks=shuffle([...Array(TYPES)].map((_,i)=>i)).slice(0,colorsToCollect); level={score:scoreTarget,moves:baseMoves,collect:{}}; collected={}; picks.forEach(t=>{ level.collect[t]=counts; collected[t]=0; }); if(mode==='moves'){ movesLeft=level.moves; } }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

  function updateGoalsUI(){ const list=$('#goalList'); list.innerHTML=''; const goals=Object.entries(level.collect||{}); let done=0, need=goals.length; goals.forEach(([t,n])=>{ const have=collected[t]|0; if(have>=n) done++; const chip=document.createElement('div'); chip.className='chip'; const dot=document.createElement('span'); dot.className='dot t'+t; chip.appendChild(dot); const txt=document.createElement('span'); txt.textContent=`Collect: ${have}/${n}`; chip.appendChild(txt); list.appendChild(chip); }); const percent=((score/level.score)*0.5 + (need? (done/need)*0.5 : 0))*100; document.getElementById('goalBar').style.width=Math.min(100,percent)+'%'; }

  function generateBoard(){ board=Array.from({length:ROWS},(_,r)=>Array.from({length:COLS},(_,c)=>{ let val; do{ val={t:randType(), s:null}; } while ((c>=2 && getType(board?.[r]?.[c-1])===val.t && getType(board?.[r]?.[c-2])===val.t) || (r>=2 && getType(board?.[r-1]?.[c])===val.t && getType(board?.[r-2]?.[c])===val.t)); return val; })); }
  function randType(){ return Math.floor(Math.random()*TYPES); }

  function renderBoard(){ elBoard.innerHTML=''; for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){ const cell=document.createElement('button'); const obj=board[r][c]; const cls=['cell']; if(obj.s==='row') cls.push('s-row'); if(obj.s==='col') cls.push('s-col'); if(obj.s==='color') cls.push('s-color'); if(obj.t>=0) cls.push('t'+obj.t); cell.className=cls.join(' '); cell.setAttribute('data-r',r); cell.setAttribute('data-c',c); cell.setAttribute('aria-label',`row ${r+1}, col ${c+1}`); cell.addEventListener('click', onCellClick); cell.addEventListener('pointerdown', onPointerDown); elBoard.appendChild(cell); } } }
  function getCellEl(r,c){ return elBoard.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }

  function onCellClick(e){ if(busy) return; const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c; if(!selected){ selected={r,c}; e.currentTarget.classList.add('selected'); return; } const prev=selected; const same=(prev.r===r && prev.c===c); if(same){ e.currentTarget.classList.remove('selected'); selected=null; return; } if(Math.abs(prev.r-r)+Math.abs(prev.c-c)!==1){ getCellEl(prev.r,prev.c)?.classList.add('pulse'); setTimeout(()=>getCellEl(prev.r,prev.c)?.classList.remove('pulse'), 400); return; } attemptSwap(prev,{r,c}); getCellEl(prev.r,prev.c)?.classList.remove('selected'); selected=null; }
  let drag=null; function onPointerDown(e){ if(busy) return; const t=e.currentTarget; t.setPointerCapture(e.pointerId); drag={r:+t.dataset.r, c:+t.dataset.c, x:e.clientX, y:e.clientY, fired:false}; function move(ev){ if(!drag||drag.fired) return; const dx=ev.clientX-drag.x, dy=ev.clientY-drag.y; const T=14; if(Math.abs(dx)<T && Math.abs(dy)<T) return; let dr=0, dc=0; if(Math.abs(dx)>Math.abs(dy)) dc=dx>0?1:-1; else dr=dy>0?1:-1; const nr=drag.r+dr, nc=drag.c+dc; if(!inBounds(nr,nc)) return; drag.fired=true; t.releasePointerCapture(ev.pointerId); attemptSwap({r:drag.r,c:drag.c},{r:nr,c:nc}); } function up(ev){ if(t.hasPointerCapture(ev.pointerId)) t.releasePointerCapture(ev.pointerId); elBoard.removeEventListener('pointermove', move); elBoard.removeEventListener('pointerup', up); drag=null; } elBoard.addEventListener('pointermove', move); elBoard.addEventListener('pointerup', up); }

  function attemptSwap(a,b){ if(busy) return; busy=true; lastSwap={a,b}; const cellA=board[a.r][a.c]; const cellB=board[b.r][b.c]; const colorBombSwap=(cellA.s==='color'||cellB.s==='color'); swap(a,b); updateCells([a,b]); sfxSwap(); if(colorBombSwap){ const targetType=(cellA.s==='color')? getType(cellB) : getType(cellA); const clear=new Set(); for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(getType(board[r][c])===targetType) clear.add(key(r,c)); clear.add(key(a.r,a.c)); clear.add(key(b.r,b.c)); return resolveMatches(clear, []).then(()=>{ if(mode==='moves'){ movesLeft=Math.max(0,movesLeft-1); updateHUD(); if(movesLeft===0) gameOver(); } busy=false; }); }
    const {clearSet, runs} = findMatches(); if(clearSet.size>0){ if(mode==='moves'){ movesLeft=Math.max(0,movesLeft-1); } resolveMatches(clearSet, runs).then(()=>{ if(mode==='moves' && movesLeft===0){ gameOver(); } busy=false; }); } else { setTimeout(()=>{ swap(a,b); updateCells([a,b]); sfxInvalid(); busy=false; }, 140); } }
  function swap(a,b){ const tmp=board[a.r][a.c]; board[a.r][a.c]=board[b.r][b.c]; board[b.r][b.c]=tmp; }
  function updateCells(list){ for(const p of list){ const el=getCellEl(p.r,p.c); if(!el) continue; const obj=board[p.r][p.c]; const cls=['cell']; if(obj.s==='row') cls.push('s-row'); if(obj.s==='col') cls.push('s-col'); if(obj.s==='color') cls.push('s-color'); if(obj.t>=0) cls.push('t'+obj.t); el.className=cls.join(' '); } }

  function findMatches(){ const clearSet=new Set(); const runs=[]; for(let r=0;r<ROWS;r++){ let st=0; for(let c=1;c<=COLS;c++){ const same=c<COLS && getType(board[r][c])===getType(board[r][st]) && getType(board[r][c])!==-1; if(!same){ const len=c-st; if(len>=3){ const cells=[]; for(let k=st;k<c;k++){ cells.push({r,c:k}); clearSet.add(key(r,k)); } runs.push({cells, orient:'h'}); } st=c; } } } for(let c=0;c<COLS;c++){ let st=0; for(let r=1;r<=ROWS;r++){ const same=r<ROWS && getType(board[r][c])===getType(board[st][c]) && getType(board[r][c])!==-1; if(!same){ const len=r-st; if(len>=3){ const cells=[]; for(let k=st;k<r;k++){ cells.push({r:k,c}); clearSet.add(key(k,c)); } runs.push({cells, orient:'v'}); } st=r; } } } return {clearSet, runs}; }

  async function resolveMatches(initial, runs){ const specialsToCreate=[]; for(const run of runs){ const len=run.cells.length; if(len>=4){ const prefer=[lastSwap?.a,lastSwap?.b].filter(Boolean).find(p=>run.cells.some(q=>q.r===p.r && q.c===p.c)); const pos=prefer||run.cells[0]; const kind=(len>=5)?'color':(run.orient==='h'?'row':'col'); specialsToCreate.push({pos,kind}); initial.delete(key(pos.r,pos.c)); } } const expanded=new Set(initial); const queue=[...initial].map(s=>s.split(',').map(Number)); while(queue.length){ const [r,c]=queue.shift(); const cell=board[r][c]; if(cell?.s==='row'){ for(let cc=0;cc<COLS;cc++){ const k=key(r,cc); if(!expanded.has(k)){ expanded.add(k); queue.push([r,cc]); } } sfxSpecial(); } else if(cell?.s==='col'){ for(let rr=0;rr<ROWS;rr++){ const k=key(rr,c); if(!expanded.has(k)){ expanded.add(k); queue.push([rr,c]); } } sfxSpecial(); } else if(cell?.s==='color'){ const neighbors=[[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(p=>inBounds(p[0],p[1])); const types=neighbors.map(p=>getType(board[p[0]][p[1]])).filter(t=>t>=0); const target=types[0] ?? randType(); for(let rr=0;rr<ROWS;rr++) for(let cc=0;cc<COLS;cc++) if(getType(board[rr][cc])===target){ const k=key(rr,cc); if(!expanded.has(k)){ expanded.add(k); queue.push([rr,cc]); } } sfxSpecial(); } }
    expanded.forEach(k=>{ const [r,c]=k.split(',').map(Number); spawnParticles(r,c, board[r][c]); });
    let clearedCount=0; const colorTally={}; expanded.forEach(k=>{ const [r,c]=k.split(',').map(Number); const t=getType(board[r][c]); if(t>=0) colorTally[t]=(colorTally[t]||0)+1; clearedCount++; }); Object.entries(colorTally).forEach(([t,n])=>{ if(collected[t]!==undefined){ collected[t]=Math.min(level.collect[t], (collected[t]||0)+n); } });
    for(const k of expanded){ const [r,c]=k.split(',').map(Number); board[r][c]=null; const el=getCellEl(r,c); el?.classList.add('clearing'); } sfxClear(clearedCount); await wait(220);
    for(const sp of specialsToCreate){ const {r,c}=sp.pos; board[r][c]={ t:(sp.kind==='color'? -1 : getType(board[r][c]) ?? randType()), s:sp.kind }; }
    dropAndFill(); renderBoard(); await wait(70);
    const gained=clearedCount*SCORE_PER_TILE; score+=gained; updateHUD(); updateGoalsUI();
    const {clearSet:more, runs:runs2}=findMatches(); if(more.size>0){ await resolveMatches(more, runs2); }
    if(mode==='moves'){ if(score>=level.score && goalsCompleted()){ sfxWin(); alert('Level complete! Goals achieved.'); } }
  }

  function goalsCompleted(){ const goals=level.collect||{}; for(const t in goals){ if((collected[t]|0) < goals[t]) return false; } return true; }
  function dropAndFill(){ for(let c=0;c<COLS;c++){ let w=ROWS-1; for(let r=ROWS-1;r>=0;r--){ if(board[r][c]!==null){ board[w][c]=board[r][c]; w--; } } for(let r=w;r>=0;r--){ board[r][c]={ t: randType(), s: null }; } } }
  function updateHUD(){ document.getElementById('score').textContent=score; document.getElementById('moves').textContent=(mode==='moves')? movesLeft : '‚àû'; }

  function gameOver(){ try{ const prev=(localStorage.getItem(NICK_KEY)||'').trim(); const name=prompt('Game over! Enter your nickname to save your score to the public leaderboard:', prev) || ''; const nick=name.trim(); if(nick){ localStorage.setItem(NICK_KEY, nick); postScore(nick, score|0).then(()=>renderLB()); } }catch(e){} alert(`Game over! Score: ${score}`); }

  const wait = ms => new Promise(res=>setTimeout(res, ms));
  function spawnParticles(r,c, cell){ const rect=getCellEl(r,c)?.getBoundingClientRect(); if(!rect) return; const host=document.getElementById('board').getBoundingClientRect(); const cx=rect.left-host.left+rect.width/2; const cy=rect.top-host.top+rect.height/2; const color=cssColorFor(cell); for(let i=0;i<8;i++){ const p=document.createElement('div'); p.className='particle'; p.style.background=color; const ang=Math.random()*Math.PI*2; const dist= 26 + Math.random()*22; p.style.left=(cx-3)+'px'; p.style.top=(cy-3)+'px'; p.style.setProperty('--dx', Math.cos(ang)*dist+'px'); p.style.setProperty('--dy', Math.sin(ang)*dist+'px'); p.style.animation='burst .5s ease-out forwards'; document.getElementById('fx').appendChild(p); setTimeout(()=>p.remove(), 520); } }
  function cssColorFor(cell){ const t = cell?.t; const map=['#ff4d4d','#ffcc00','#33ccff','#66ff66','#cc66ff','#ff66cc']; return (cell?.s==='color')? '#ffffff' : map[(t>=0?t:0)%map.length]; }

  async function renderLB(){ const listEl=document.getElementById('lbList'); if(!listEl) return; const list=await fetchLB(10); if(!list||list.length===0){ listEl.innerHTML='<div class="empty">No scores yet or leaderboard offline.</div>'; return;} listEl.innerHTML=list.map((r,i)=>`<div class="row"><span class="name">${i+1}. ${escapeHtml(r.name)}</span><span class="pts">${r.score}</span></div>`).join(''); }
  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m])); }

  window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
