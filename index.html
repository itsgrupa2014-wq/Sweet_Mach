
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sweet Match ‚Äî Glossy Balls (Pro)</title>
<style>
  :root{
    --cell: 68px;
    --gap: 8px;
    --bg: #0b0f18;
    --panel: #101727;
    --text: #eaf0ff;
    --accent: #7aa2ff;
    --ok: #35d07f;
    --warn: #ffd36e;
  }
  *{box-sizing:border-box}
  html,body{height:100%;}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", Arial;
    background: radial-gradient(1200px 800px at 80% -10%, #1c2657 0, var(--bg) 55%);
    color: var(--text);
    display:flex; align-items:center; justify-content:center;
    padding: 16px;
  }
  .app{ display:grid; grid-template-columns: 1fr 340px; gap: 18px; align-items:start; }
  .board-wrap{ position:relative; background:
      radial-gradient(120% 100% at 10% 0%, rgba(255,255,255,.04), rgba(255,255,255,0) 60%),
      color-mix(in srgb, #000 18%, var(--panel));
    padding:16px; border-radius:18px; box-shadow: 0 10px 28px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.06); }
  .board{ display:grid; grid-template-columns: repeat(8, var(--cell)); grid-template-rows: repeat(8, var(--cell)); gap: var(--gap); touch-action: none; }
  .fx{ position:absolute; inset:16px; pointer-events:none; }

  /* glossy ball base */
  .cell{
    width: var(--cell); height: var(--cell); border-radius: 50%; cursor:pointer; position:relative; transition: transform .08s ease, filter .15s ease;
    box-shadow:
      inset 0 -10px 16px rgba(0,0,0,.35),
      inset 0 10px 14px rgba(255,255,255,.18),
      0 8px 12px rgba(0,0,0,.35);
    display:block; border:none; padding:0; background: transparent;
    touch-action: none;
  }
  .cell:active{ transform: scale(.94); }
  .selected{ outline: 3px solid rgba(255,255,255,.85); outline-offset: 3px; filter: saturate(1.2) brightness(1.05); }
  .pulse{ animation: pulse .5s ease; }
  @keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.08)} 100%{transform:scale(1)} }
  .clearing{ animation: pop .35s ease-in forwards; }
  @keyframes pop{ to{ transform: scale(0); opacity: 0; } }

  /* glossy layers ‚Äî color plus highlight and spec */
  .cell::before, .cell::after{ content:""; position:absolute; inset:0; border-radius:50%; pointer-events:none; }
  /* highlight band */
  .cell::before{
    background: linear-gradient(160deg, rgba(255,255,255,.25) 0%, rgba(255,255,255,.08) 35%, rgba(0,0,0,.0) 40%, rgba(0,0,0,.25) 100%);
    mix-blend-mode: screen; opacity:.9;
    clip-path: ellipse(85% 55% at 30% 20%);
    transform: translate(-6%, -6%) rotate(-8deg);
  }
  /* specular spot */
  .cell::after{
    background: radial-gradient(60% 60% at 28% 22%, rgba(255,255,255,.85) 0 22%, rgba(255,255,255,.0) 40%),
                radial-gradient(40% 40% at 70% 70%, rgba(0,0,0,.3) 0 60%, rgba(0,0,0,0) 70%);
  }

  /* BRIGHT color variants (flat vivid bases) */
  .t0{ background: linear-gradient(#ff4d4d, #ff4d4d); }
  .t1{ background: linear-gradient(#ffcc00, #ffcc00); }
  .t2{ background: linear-gradient(#33ccff, #33ccff); }
  .t3{ background: linear-gradient(#66ff66, #66ff66); }
  .t4{ background: linear-gradient(#cc66ff, #cc66ff); }
  .t5{ background: linear-gradient(#ff66cc, #ff66cc); }

  /* special styles */
  .s-row::before{ content:""; position:absolute; inset:0; border-radius:50%; background:
      repeating-linear-gradient(90deg, rgba(255,255,255,.35) 0 6px, rgba(255,255,255,0) 6px 12px);
    mix-blend-mode: screen; opacity:.7; clip-path: circle(48% at 50% 50%); }
  .s-col::before{ content:""; position:absolute; inset:0; border-radius:50%; background:
      repeating-linear-gradient(0deg, rgba(255,255,255,.35) 0 6px, rgba(255,255,255,0) 6px 12px);
    mix-blend-mode: screen; opacity:.7; clip-path: circle(48% at 50% 50%); }
  .s-color{ background:
      conic-gradient(from 0deg, #ff4d4d, #ffcc00, #33ccff, #66ff66, #cc66ff, #ff66cc, #ff4d4d);
    box-shadow: inset 0 10px 18px rgba(255,255,255,.25), inset 0 -10px 18px rgba(0,0,0,.35), 0 8px 12px rgba(0,0,0,.35); }

  .sidebar{ background:
      radial-gradient(140% 120% at 0% 0%, rgba(255,255,255,.05), rgba(255,255,255,0) 50%),
      color-mix(in srgb, #000 14%, var(--panel));
    padding:18px; border-radius:18px; width: 100%; max-width: 380px;
    box-shadow: 0 10px 28px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.05); }
  h1{ font-size: 22px; margin:0 0 12px 0; letter-spacing:.2px }
  .meta{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 12px 0 16px; }
  .card{ background: #0d1328; border: 1px solid rgba(255,255,255,.09); border-radius: 12px; padding: 12px; text-align:center; }
  .label{ font-size: 12px; opacity:.8; }
  .value{ font-size: 26px; font-weight: 800; margin-top: 2px; }
  .btns{ display:flex; gap:10px; flex-wrap:wrap }
  button{ background: linear-gradient(180deg,#5f85ff,#3c5df7); color:white; border:none; padding:11px 14px; border-radius:12px; cursor:pointer; font-weight:700; box-shadow: 0 8px 18px rgba(60,93,247,.35); }
  button.secondary{ background: none; border:1px solid rgba(255,255,255,.18); color: var(--text); box-shadow:none }
  .help{ font-size: 13px; opacity:.92; line-height:1.6; margin-top: 12px; }

  .goals{ margin-top: 10px; display:grid; gap:10px; }
  .goal{ background:#0d1328; border:1px solid rgba(255,255,255,.09); padding:10px; border-radius:10px; }
  .goal h3{ margin:0 0 6px; font-size:14px; letter-spacing:.2px }
  .progress{ height:8px; background:#0b0f1a; border-radius:99px; overflow:hidden; border:1px solid rgba(255,255,255,.08) }
  .bar{ height:100%; background: linear-gradient(90deg, var(--ok), #8af0b6); width:0% }
  .goal-list{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px }
  .chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 8px; border-radius:999px; background:#0b0f1a; border:1px solid rgba(255,255,255,.08); font-size:12px }
  .dot{ width:14px; height:14px; border-radius:50% }

  /* donation section (simple) */
  .donate{ margin-top: 14px; padding-top: 12px; border-top: 1px dashed rgba(255,255,255,.15); font-size:13px; opacity:.95; }
  .donate a{ color:#7aa2ff; text-decoration:underline; }

  /* particles */
  .particle{ position:absolute; width:6px; height:6px; border-radius:50%; opacity:1; will-change: transform, opacity; }
  @keyframes burst{ to{ transform: translate(var(--dx), var(--dy)) scale(.3); opacity: 0; } }

  /* modal */
  .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.4); backdrop-filter: blur(2px); }
  .modal.show{ display:flex }
  .modal .box{ background:#0f1430; border:1px solid rgba(255,255,255,.12); padding:18px; border-radius:14px; width:min(92vw, 420px); }
  .modal h2{ margin:0 0 8px; }
  .modal p{ margin:0 0 12px; opacity:.9 }

  @media (max-width: 900px){
    :root{ --cell: 56px; --gap: 7px; }
    .app{ grid-template-columns: 1fr; }
    body{ align-items:flex-start }
  }
</style>
</head>
<body>
  <div class="app">
    <div class="board-wrap">
      <div id="board" class="board" aria-label="Game board 8x8"></div>
      <div id="fx" class="fx"></div>
    </div>
    <aside class="sidebar">
      <h1>Sweet Match üç¨</h1>
      <div class="meta">
        <div class="card"><div class="label">Score</div><div id="score" class="value">0</div></div>
        <div class="card"><div class="label">Moves</div><div id="moves" class="value">30</div></div>
      </div>
      <div class="btns">
        <button id="newGame">New game</button>
        <button id="toggleMode" class="secondary">Mode: Moves</button>
        <button id="nextLevel" class="secondary" title="Skip to the next level">Next level</button>
      </div>
      <div class="goals">
        <div class="goal">
          <h3>Level goals</h3>
          <div class="progress"><div id="goalBar" class="bar"></div></div>
          <div id="goalList" class="goal-list"></div>
        </div>
      </div>
      <div class="help">
        <strong>How to play:</strong> click a ball, then click a neighboring cell (up/down/left/right) to swap and make matches of 3+. A line of 4 creates a <em>row/column blaster</em>, and 5 creates a <em>color bomb</em>.
      </div>
      
<div class="donate">
<a class="paybtn" style="display:inline-flex;align-items:center;gap:10px;background:linear-gradient(180deg,#15a2ff,#0a7bd6);padding:10px 14px;border-radius:12px;color:white;font-weight:700;text-decoration:none;box-shadow:0 8px 18px rgba(21,162,255,.35);" href="https://paypal.me/AR110688" target="_blank" rel="noopener">Donate via PayPal</a>
</div>

    </aside>
  </div>

  <div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="box">
      <h2 id="modalTitle">Level complete!</h2>
      <p id="modalText">Great job ‚Äî goals achieved.</p>
      <div class="btns"><button id="modalNext">Next level</button><button id="modalClose" class="secondary">Close</button></div>
    </div>
  </div>

<script>
  /* The JavaScript engine remains the same as your PRO version ‚Äî only UI texts and colors were updated. */
  /* ==== Game Engine (copied from your PRO version with click+drag support) ==== */
  const ROWS = 8, COLS = 8, TYPES = 6;
  const MOVE_LIMIT = 30;
  const SCORE_PER_TILE = 10;

  let board = [];
  let elBoard, elFX;
  let selected = null;
  let busy = false;
  let score = 0;
  let movesLeft = MOVE_LIMIT;
  let mode = 'moves';
  let lastSwap = null;

  let levelIndex = 0;
  let level = null;
  let collected = {};

  const $ = sel => document.querySelector(sel);

  const Audio = {
    ctx: null,
    ensure(){ if(!this.ctx){ try{ this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){} } },
    beep(freq=440, dur=0.07, type='sine', gain=0.05){ this.ensure(); if(!this.ctx) return; const t=this.ctx.currentTime; const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); o.type=type; o.frequency.setValueAtTime(freq, t); g.gain.setValueAtTime(gain, t); g.gain.exponentialRampToValueAtTime(0.0001, t+dur); o.connect(g).connect(this.ctx.destination); o.start(t); o.stop(t+dur); },
    chord(freqs=[440,660], dur=0.12, type='sine', gain=0.04){ this.ensure(); if(!this.ctx) return; const t=this.ctx.currentTime; const g=this.ctx.createGain(); g.gain.setValueAtTime(gain, t); g.connect(this.ctx.destination); freqs.forEach((f)=>{ const o=this.ctx.createOscillator(); o.type=type; o.frequency.setValueAtTime(f, t); o.connect(g); o.start(t); o.stop(t+dur); }); g.gain.exponentialRampToValueAtTime(0.0001, t+dur); }
  };
  function sfxSwap(){ Audio.beep(420,0.06,'triangle',0.04); }
  function sfxInvalid(){ Audio.beep(180,0.10,'sawtooth',0.03); }
  function sfxClear(n=3){ Audio.chord([520,660,820].slice(0,Math.min(3,Math.max(1,n/3|0))),0.12,'sine',0.04); }
  function sfxSpecial(){ Audio.chord([320,480,640],0.16,'square',0.035); }
  function sfxWin(){ Audio.chord([660,880,990],0.3,'sine',0.05); }

  const inBounds = (r,c)=> r>=0 && r<ROWS && c>=0 && c<COLS;
  const key = (r,c)=> r+","+c;
  const getType = (cell)=> cell?.t;

  function init(){
    elBoard = $('#board'); elFX = $('#fx');
    $('#newGame').addEventListener('click', newGame);
    $('#toggleMode').addEventListener('click', toggleMode);
    $('#nextLevel').addEventListener('click', ()=>{ levelIndex++; newGame(true); });
    $('#modalNext').addEventListener('click', ()=>{ hideModal(); levelIndex++; newGame(true); });
    $('#modalClose').addEventListener('click', hideModal);
    newGame();
  }

  function toggleMode(){
    mode = (mode === 'moves') ? 'endless' : 'moves';
    $('#toggleMode').textContent = `Mode: ${mode === 'moves' ? 'Moves' : 'Endless'}`;
    newGame();
  }

  function newGame(keepMode=false){
    score = 0; movesLeft = MOVE_LIMIT; updateHUD();
    setupLevel(); updateGoalsUI();
    generateBoard();
    renderBoard();
    if(!keepMode) selected = null;
  }

  function setupLevel(){
    const baseMoves = MOVE_LIMIT;
    const scoreTarget = 300 + levelIndex*150;
    const colorsToCollect = 2 + (levelIndex%3);
    const counts = 8 + Math.min(20, levelIndex*3);
    const picks = shuffle([...Array(TYPES)].map((_,i)=>i)).slice(0, colorsToCollect);
    level = { score: scoreTarget, moves: baseMoves, collect: {} };
    collected = {};
    picks.forEach(t=>{ level.collect[t] = counts; collected[t] = 0; });
    if(mode==='moves'){ movesLeft = level.moves; }
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

  function updateGoalsUI(){
    const list = $('#goalList'); list.innerHTML = '';
    const goals = Object.entries(level.collect||{});
    let doneCount=0, needCount=goals.length;
    goals.forEach(([t,need])=>{
      const have = collected[t]|0;
      if(have>=need) doneCount++;
      const chip = document.createElement('div'); chip.className='chip';
      const dot = document.createElement('span'); dot.className='dot t'+t; chip.appendChild(dot);
      const txt = document.createElement('span'); txt.textContent = `Collect: ${have}/${need}`; chip.appendChild(txt);
      list.appendChild(chip);
    });
    const percent = ((score / level.score) * 0.5 + (needCount? (doneCount/needCount)*0.5 : 0))*100;
    $('#goalBar').style.width = Math.min(100, percent)+'%';
  }

  function generateBoard(){
    board = Array.from({length: ROWS}, (_,r) => Array.from({length: COLS}, (_,c) => {
      let val;
      do{
        val = { t: randType(), s: null };
      } while ((c>=2 && getType(board?.[r]?.[c-1])===val.t && getType(board?.[r]?.[c-2])===val.t) ||
               (r>=2 && getType(board?.[r-1]?.[c])===val.t && getType(board?.[r-2]?.[c])===val.t));
      return val;
    }));
  }
  function randType(){ return Math.floor(Math.random()*TYPES); }

  function renderBoard(){
    elBoard.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = document.createElement('button');
        const obj = board[r][c];
        const cls = ['cell'];
        if(obj.s==='row') cls.push('s-row');
        if(obj.s==='col') cls.push('s-col');
        if(obj.s==='color') cls.push('s-color');
        if(obj.t>=0) cls.push('t'+obj.t);
        cell.className = cls.join(' ');
        cell.setAttribute('data-r', r);
        cell.setAttribute('data-c', c);
        cell.setAttribute('aria-label', `row ${r+1}, col ${c+1}`);
        cell.addEventListener('click', onCellClick);
        cell.addEventListener('pointerdown', onPointerDown);
        elBoard.appendChild(cell);
      }
    }
  }

  function getCellEl(r,c){ return elBoard.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }

  function onCellClick(e){
    if(busy) return;
    const r = +e.currentTarget.dataset.r, c = +e.currentTarget.dataset.c;
    if(!selected){ selected = {r,c}; e.currentTarget.classList.add('selected'); return; }
    const prev = selected; const same = (prev.r===r && prev.c===c);
    if(same){ e.currentTarget.classList.remove('selected'); selected = null; return; }
    if(Math.abs(prev.r - r) + Math.abs(prev.c - c) !== 1){
      getCellEl(prev.r, prev.c)?.classList.add('pulse'); setTimeout(()=>getCellEl(prev.r, prev.c)?.classList.remove('pulse'), 400); return;
    }
    attemptSwap(prev, {r,c}); getCellEl(prev.r, prev.c)?.classList.remove('selected'); selected = null;
  }

  let drag = null;
  function onPointerDown(e){
    if(busy) return;
    const target = e.currentTarget; target.setPointerCapture(e.pointerId);
    drag = { r:+target.dataset.r, c:+target.dataset.c, x:e.clientX, y:e.clientY, fired:false };
    function move(ev){ if(!drag||drag.fired) return; const dx=ev.clientX-drag.x, dy=ev.clientY-drag.y; const t=14; if(Math.abs(dx)<t && Math.abs(dy)<t) return; let dr=0, dc=0; if(Math.abs(dx)>Math.abs(dy)) dc = dx>0?1:-1; else dr = dy>0?1:-1; const nr=drag.r+dr, nc=drag.c+dc; if(!inBounds(nr,nc)) return; drag.fired=true; target.releasePointerCapture(ev.pointerId); attemptSwap({r:drag.r,c:drag.c},{r:nr,c:nc}); }
    function up(ev){ if(target.hasPointerCapture(ev.pointerId)) target.releasePointerCapture(ev.pointerId); elBoard.removeEventListener('pointermove', move); elBoard.removeEventListener('pointerup', up); drag=null; }
    elBoard.addEventListener('pointermove', move); elBoard.addEventListener('pointerup', up);
  }

  function attemptSwap(a,b){
    if(busy) return; busy = true; lastSwap = {a,b};
    const cellA = board[a.r][a.c];
    const cellB = board[b.r][b.c];
    const colorBombSwap = (cellA.s==='color' || cellB.s==='color');
    swap(a,b); updateCells([a,b]); sfxSwap();

    if(colorBombSwap){
      const targetType = (cellA.s==='color') ? getType(cellB) : getType(cellA);
      const clear = new Set();
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(getType(board[r][c])===targetType) clear.add(key(r,c));
      clear.add(key(a.r,a.c)); clear.add(key(b.r,b.c));
      return resolveMatches(clear, []).then(()=>{ if(mode==='moves') { movesLeft = Math.max(0, movesLeft-1); updateHUD(); if(movesLeft===0) gameOver(); } busy=false; });
    }

    const {clearSet, runs} = findMatches();
    if(clearSet.size>0){
      if(mode==='moves') { movesLeft = Math.max(0, movesLeft-1); }
      resolveMatches(clearSet, runs).then(()=>{ if(mode==='moves' && movesLeft===0){ gameOver(); } busy=false; });
    } else {
      setTimeout(()=>{ swap(a,b); updateCells([a,b]); sfxInvalid(); busy=false; }, 140);
    }
  }

  function swap(a,b){ const tmp = board[a.r][a.c]; board[a.r][a.c] = board[b.r][b.c]; board[b.r][b.c] = tmp; }

  function updateCells(list){ for(const p of list){ const el = getCellEl(p.r,p.c); if(!el) continue; const obj = board[p.r][p.c]; const cls=['cell']; if(obj.s==='row') cls.push('s-row'); if(obj.s==='col') cls.push('s-col'); if(obj.s==='color') cls.push('s-color'); if(obj.t>=0) cls.push('t'+obj.t); el.className = cls.join(' '); } }

  function findMatches(){
    const clearSet = new Set();
    const runs = [];
    for(let r=0;r<ROWS;r++){
      let runStart=0;
      for(let c=1;c<=COLS;c++){
        const same = c<COLS && getType(board[r][c])===getType(board[r][runStart]) && getType(board[r][c])!==-1;
        if(!same){
          const len = c-runStart;
          if(len>=3){
            const cells=[]; for(let k=runStart;k<c;k++){ cells.push({r,c:k}); clearSet.add(key(r,k)); }
            runs.push({cells, orient:'h'});
          }
          runStart=c;
        }
      }
    }
    for(let c=0;c<COLS;c++){
      let runStart=0;
      for(let r=1;r<=ROWS;r++){
        const same = r<ROWS && getType(board[r][c])===getType(board[runStart][c]) && getType(board[r][c])!==-1;
        if(!same){
          const len = r-runStart;
          if(len>=3){
            const cells=[]; for(let k=runStart;k<r;k++){ cells.push({r:k,c}); clearSet.add(key(k,c)); }
            runs.push({cells, orient:'v'});
          }
          runStart=r;
        }
      }
    }
    return {clearSet, runs};
  }

  async function resolveMatches(initial, runs){
    const specialsToCreate = [];
    for(const run of runs){
      const len = run.cells.length;
      if(len>=4){
        const prefer = [lastSwap?.a, lastSwap?.b].filter(Boolean).find(p => run.cells.some(q=>q.r===p.r && q.c===p.c));
        const pos = prefer || run.cells[0];
        const kind = (len>=5) ? 'color' : (run.orient==='h' ? 'row' : 'col');
        specialsToCreate.push({pos, kind});
        initial.delete(key(pos.r, pos.c));
      }
    }

    const expanded = new Set(initial);
    const queue = [...initial].map(s=>s.split(',').map(Number));
    while(queue.length){
      const [r,c] = queue.shift();
      const cell = board[r][c];
      if(cell?.s==='row'){
        for(let cc=0;cc<COLS;cc++){ const k=key(r,cc); if(!expanded.has(k)){ expanded.add(k); queue.push([r,cc]); } }
        sfxSpecial();
      } else if(cell?.s==='col'){
        for(let rr=0;rr<ROWS;rr++){ const k=key(rr,c); if(!expanded.has(k)){ expanded.add(k); queue.push([rr,c]); } }
        sfxSpecial();
      } else if(cell?.s==='color'){
        const neighbors = [ [r-1,c],[r+1,c],[r,c-1],[r,c+1] ].filter(p=>inBounds(p[0],p[1]));
        const types = neighbors.map(p=>getType(board[p[0]][p[1]])).filter(t=>t>=0);
        const target = types[0] ?? randType();
        for(let rr=0;rr<ROWS;rr++) for(let cc=0;cc<COLS;cc++) if(getType(board[rr][cc])===target){ const k=key(rr,cc); if(!expanded.has(k)){ expanded.add(k); queue.push([rr,cc]); } }
        sfxSpecial();
      }
    }

    expanded.forEach(k=>{ const [r,c] = k.split(',').map(Number); spawnParticles(r,c, board[r][c]); });

    let clearedCount = 0; const colorTally = {};
    expanded.forEach(k=>{ const [r,c] = k.split(',').map(Number); const t = getType(board[r][c]); if(t>=0) colorTally[t] = (colorTally[t]||0)+1; clearedCount++; });
    Object.entries(colorTally).forEach(([t,n])=>{ if(collected[t]!==undefined){ collected[t] = Math.min(level.collect[t], (collected[t]||0)+n); } });

    for(const k of expanded){ const [r,c] = k.split(',').map(Number); board[r][c] = null; const el = getCellEl(r,c); el?.classList.add('clearing'); }
    sfxClear(clearedCount);
    await wait(220);

    for(const sp of specialsToCreate){
      const {r,c} = sp.pos; board[r][c] = { t: (sp.kind==='color' ? -1 : getType(board[r][c]) ?? randType()), s: sp.kind };
    }

    dropAndFill();
    renderBoard();
    await wait(70);

    const gained = clearedCount * SCORE_PER_TILE; score += gained; updateHUD(); updateGoalsUI();

    const {clearSet: more, runs: runs2} = findMatches();
    if(more.size>0){ await resolveMatches(more, runs2); }

    if(mode==='moves'){
      if(score>=level.score && goalsCompleted()){ showWin(); }
    }
  }

  function goalsCompleted(){
    const goals = level.collect || {}; for(const t in goals){ if((collected[t]|0) < goals[t]) return false; } return true;
  }

  function dropAndFill(){
    for(let c=0;c<COLS;c++){
      let writeRow = ROWS-1;
      for(let r=ROWS-1;r>=0;r--){
        if(board[r][c]!==null){ board[writeRow][c] = board[r][c]; writeRow--; }
      }
      for(let r=writeRow;r>=0;r--){ board[r][c] = { t: randType(), s: null }; }
    }
  }

  function updateHUD(){ $('#score').textContent = score; $('#moves').textContent = (mode==='moves') ? movesLeft : '‚àû'; }

  function gameOver(){ alert(`Game over! Score: ${score}`); }

  function showWin(){ sfxWin(); const m=$('#modal'); m.classList.add('show'); $('#modalTitle').textContent = 'Level complete!'; $('#modalText').textContent = 'Great job ‚Äî goals achieved.'; }
  function hideModal(){ $('#modal').classList.remove('show'); }

  const wait = ms => new Promise(res=>setTimeout(res, ms));

  function spawnParticles(r,c, cell){
    const rect = getCellEl(r,c)?.getBoundingClientRect(); if(!rect) return;
    const host = elBoard.getBoundingClientRect();
    const cx = rect.left - host.left + rect.width/2; const cy = rect.top - host.top + rect.height/2;
    const color = cssColorFor(cell);
    for(let i=0;i<8;i++){
      const p = document.createElement('div'); p.className='particle'; p.style.background=color; const ang=Math.random()*Math.PI*2; const dist= 26 + Math.random()*22; p.style.left=(cx-3)+'px'; p.style.top=(cy-3)+'px'; p.style.setProperty('--dx', Math.cos(ang)*dist+'px'); p.style.setProperty('--dy', Math.sin(ang)*dist+'px'); p.style.animation='burst .5s ease-out forwards'; elFX.appendChild(p); setTimeout(()=>p.remove(), 520);
    }
  }
  function cssColorFor(cell){
    const t = getType(cell); const map = ['#ff4d4d','#ffcc00','#33ccff','#66ff66','#cc66ff','#ff66cc']; return (cell?.s==='color')?'#ffffff': map[(t>=0?t:0)%map.length];
  }

  window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
